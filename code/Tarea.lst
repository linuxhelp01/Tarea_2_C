CCS PCM C Compiler, Version 5.112, 5967               19-nov.-25 16:52

               Filename:   C:\Users\felip\OneDrive\Desktop\C\code\Tarea.lst

               ROM used:   168 words (2%)
                           Largest free fragment is 2048
               RAM used:   6 (2%) at main() level
                           10 (3%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   087
0003:  NOP
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
.................... 
.................... #list
.................... 
.................... #fuses HS,NOWDT,NOPUT,NOLVP,NOPROTECT,BROWNOUT
.................... #use delay(clock=20M)
*
004A:  MOVLW  21
004B:  MOVWF  04
004C:  BCF    03.7
004D:  MOVF   00,W
004E:  BTFSC  03.2
004F:  GOTO   05D
0050:  MOVLW  06
0051:  MOVWF  78
0052:  CLRF   77
0053:  DECFSZ 77,F
0054:  GOTO   053
0055:  DECFSZ 78,F
0056:  GOTO   052
0057:  MOVLW  7B
0058:  MOVWF  77
0059:  DECFSZ 77,F
005A:  GOTO   059
005B:  DECFSZ 00,F
005C:  GOTO   050
.................... 
.................... #include "display_max.c"
.................... // Pines del MAX7219
.................... #define MAX_DIN   PIN_B0
.................... #define MAX_CLK   PIN_B1
.................... #define MAX_CS    PIN_B2
.................... 
.................... void max_pulse_clk(void) {
....................    output_high(MAX_CLK);
*
0014:  BSF    03.5
0015:  BCF    06.1
0016:  BCF    03.5
0017:  BSF    06.1
....................    delay_us(1);
0018:  GOTO   019
0019:  GOTO   01A
001A:  NOP
....................    output_low(MAX_CLK);
001B:  BSF    03.5
001C:  BCF    06.1
001D:  BCF    03.5
001E:  BCF    06.1
.................... }
.................... 
.................... void max_sendByte(unsigned int8 data) {
....................    int i;
....................    // Compara el valor ingresado con 0b10000000
....................    for(i = 0; i < 8; i++) {
*
0004:  CLRF   24
0005:  MOVF   24,W
0006:  SUBLW  07
0007:  BTFSS  03.0
0008:  GOTO   023
....................       if(data & 0x80) // Si cumple la condicion AND envia un bit alto
0009:  BTFSS  23.7
000A:  GOTO   010
....................          output_high(MAX_DIN);
000B:  BSF    03.5
000C:  BCF    06.0
000D:  BCF    03.5
000E:  BSF    06.0
000F:  GOTO   014
....................       else // En caso contrario un bit en bajo
....................          output_low(MAX_DIN);
0010:  BSF    03.5
0011:  BCF    06.0
0012:  BCF    03.5
0013:  BCF    06.0
.................... 
....................       max_pulse_clk(); // Determiando el estado del bit, se confirma mediante un flanco de subida
....................       
....................       data <<= 1; //corre el arreglo de bits a la izq 
*
001F:  BCF    03.0
0020:  RLF    23,F
0021:  INCF   24,F
0022:  GOTO   005
....................    }
0023:  RETURN
.................... }
.................... 
.................... void max_send(unsigned int8 reg, unsigned int8 data) {
....................    output_low(MAX_CS);
0024:  BSF    03.5
0025:  BCF    06.2
0026:  BCF    03.5
0027:  BCF    06.2
....................    max_sendByte(reg);
0028:  MOVF   21,W
0029:  MOVWF  23
002A:  CALL   004
....................    max_sendByte(data);
002B:  MOVF   22,W
002C:  MOVWF  23
002D:  CALL   004
....................    output_high(MAX_CS);
002E:  BSF    03.5
002F:  BCF    06.2
0030:  BCF    03.5
0031:  BSF    06.2
0032:  RETURN
.................... }
.................... 
.................... void max_init(void) {
....................    // RB0,RB1,RB2 como salida
....................    set_tris_b(0b11111000);   // RB0-2 = 0 (salida); RB3-7 entrada
0033:  MOVLW  F8
0034:  BSF    03.5
0035:  MOVWF  06
....................    setup_adc_ports(NO_ANALOGS);
0036:  BSF    1F.0
0037:  BSF    1F.1
0038:  BSF    1F.2
0039:  BCF    1F.3
....................    setup_adc(ADC_OFF);
003A:  BCF    03.5
003B:  BCF    1F.0
.................... 
....................    output_low(MAX_DIN);
003C:  BSF    03.5
003D:  BCF    06.0
003E:  BCF    03.5
003F:  BCF    06.0
....................    output_low(MAX_CLK);
0040:  BSF    03.5
0041:  BCF    06.1
0042:  BCF    03.5
0043:  BCF    06.1
....................    output_high(MAX_CS);
0044:  BSF    03.5
0045:  BCF    06.2
0046:  BCF    03.5
0047:  BSF    06.2
.................... 
....................    delay_ms(50);
0048:  MOVLW  32
0049:  MOVWF  21
.................... 
....................    // Config básica
....................    max_send(0x0F, 0x00);   // test off
*
005D:  MOVLW  0F
005E:  MOVWF  21
005F:  CLRF   22
0060:  CALL   024
....................    max_send(0x0C, 0x01);   // salir de shutdown (modo normal)
0061:  MOVLW  0C
0062:  MOVWF  21
0063:  MOVLW  01
0064:  MOVWF  22
0065:  CALL   024
....................    max_send(0x0B, 0x03);   // scan limit: muestra 4 digitos
0066:  MOVLW  0B
0067:  MOVWF  21
0068:  MOVLW  03
0069:  MOVWF  22
006A:  CALL   024
....................    max_send(0x0A, 0x08);   // intensidad media
006B:  MOVLW  0A
006C:  MOVWF  21
006D:  MOVLW  08
006E:  MOVWF  22
006F:  CALL   024
....................    max_send(0x09, 0x0F);   // decode mode: solo DIG0 en BCD (registro 1)
0070:  MOVLW  09
0071:  MOVWF  21
0072:  MOVLW  0F
0073:  MOVWF  22
0074:  CALL   024
0075:  BCF    0A.3
0076:  BCF    0A.4
0077:  GOTO   095 (RETURN)
.................... }
.................... 
.................... #include "Estanque.c"
.................... #include "Botton.c"
.................... 
.................... #define BTN1   PIN_E0
.................... #define BTN2   PIN_E1
.................... #define BTN3   PIN_E2
.................... 
.................... int1 estado = 0;   // Estado de algo (LED, modo, etc.)
.................... 
.................... void conf_button(){
....................    // Desactivar entradas analógicas: usar todos los pines como digitales
....................    setup_adc_ports(NO_ANALOGS);
0078:  BSF    03.5
0079:  BSF    1F.0
007A:  BSF    1F.1
007B:  BSF    1F.2
007C:  BCF    1F.3
....................    setup_adc(ADC_OFF);
007D:  BCF    03.5
007E:  BCF    1F.0
.................... 
....................    // RE0, RE1, RE2 como ENTRADAS (1); resto de RE como salida (0)
....................    // bit0 -> RE0, bit1 -> RE1, bit2 -> RE2
....................    set_tris_e(0b00000111);
007F:  BSF    03.5
0080:  BSF    09.0
0081:  BSF    09.1
0082:  BSF    09.2
0083:  BCF    03.5
0084:  BCF    0A.3
0085:  BCF    0A.4
0086:  GOTO   096 (RETURN)
.................... }
.................... 
.................... void WaitBoton() {
....................    // Asumimos botón con pull-up: en reposo = 1, presionado = 0
....................    while (input(BTN1)) {
....................       // espera a que se PRESIONE
....................    }
....................    delay_ms(20);  // anti-rebote
....................    while (!input(BTN1)) {
....................       // espera a que se SUELTE
....................    }
....................    delay_ms(20);  // anti-rebote
.................... }
.................... 
.................... 
.................... void state_boton() {
....................   WaitBoton();         // Espera a que el usuario presione y suelte
.................... 
....................   // Aquí SIEMPRE entras después de un cambio de estado del botón
....................   estado = !estado;    // Cambias el estado (toggle)
.................... 
....................   if (estado) {
....................     // Código para el estado "ON"
....................     
....................   } else {
....................     
....................   }
.................... }
.................... 
.................... 
.................... void main() {
....................    max_init();
0087:  MOVF   03,W
0088:  ANDLW  1F
0089:  MOVWF  03
008A:  BCF    20.0
008B:  BSF    03.5
008C:  BSF    1F.0
008D:  BSF    1F.1
008E:  BSF    1F.2
008F:  BCF    1F.3
0090:  MOVLW  07
0091:  MOVWF  1C
0092:  BCF    03.7
....................    conf_button();
0093:  BCF    03.5
0094:  GOTO   033
.................... 
0095:  GOTO   078
....................    // Mostrar el número 8 en el dígito 0 (registro 1)
....................    max_send(1, 1);
....................    max_send(2, 2);
0096:  MOVLW  01
0097:  MOVWF  21
0098:  MOVWF  22
0099:  CALL   024
....................    max_send(3, 3);
009A:  MOVLW  02
009B:  MOVWF  21
009C:  MOVWF  22
009D:  CALL   024
....................    max_send(4, 4);
009E:  MOVLW  03
009F:  MOVWF  21
00A0:  MOVWF  22
00A1:  CALL   024
....................    
00A2:  MOVLW  04
00A3:  MOVWF  21
00A4:  MOVWF  22
00A5:  CALL   024
....................    while(TRUE) {
....................       // no hace nada más
00A6:  GOTO   0A6
....................    }
.................... }
.................... 
00A7:  SLEEP

Configuration Fuses:
   Word  1: 3F7A   HS NOWDT NOPUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
