CCS PCM C Compiler, Version 5.112, 5967               23-nov.-25 23:53

               Filename:   C:\Users\felip\OneDrive\Desktop\C\code\Tarea.lst

               ROM used:   357 words (4%)
                           Largest free fragment is 2048
               RAM used:   13 (4%) at main() level
                           17 (5%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   0F9
0003:  NOP
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
*
00E4:  MOVF   29,W
00E5:  CLRF   78
00E6:  SUBWF  28,W
00E7:  BTFSC  03.0
00E8:  GOTO   0EC
00E9:  MOVF   28,W
00EA:  MOVWF  77
00EB:  GOTO   0F8
00EC:  CLRF   77
00ED:  MOVLW  08
00EE:  MOVWF  2A
00EF:  RLF    28,F
00F0:  RLF    77,F
00F1:  MOVF   29,W
00F2:  SUBWF  77,W
00F3:  BTFSC  03.0
00F4:  MOVWF  77
00F5:  RLF    78,F
00F6:  DECFSZ 2A,F
00F7:  GOTO   0EF
00F8:  RETURN
.................... 
.................... #list
.................... 
.................... #fuses HS,NOWDT,NOPUT,NOLVP,NOPROTECT,BROWNOUT
.................... #use delay(clock=4M) // Ajustar según tu cristal (4M o 20M)
*
0004:  MOVLW  27
0005:  MOVWF  04
0006:  BCF    03.7
0007:  MOVF   00,W
0008:  BTFSC  03.2
0009:  GOTO   018
000A:  MOVLW  01
000B:  MOVWF  78
000C:  CLRF   77
000D:  DECFSZ 77,F
000E:  GOTO   00D
000F:  DECFSZ 78,F
0010:  GOTO   00C
0011:  MOVLW  4A
0012:  MOVWF  77
0013:  DECFSZ 77,F
0014:  GOTO   013
0015:  GOTO   016
0016:  DECFSZ 00,F
0017:  GOTO   00A
0018:  RETURN
.................... 
.................... #include "display_max.c"
.................... // display_max.c - Driver para MAX7219
.................... #define MAX_DIN   PIN_B0
.................... #define MAX_CLK   PIN_B1
.................... #define MAX_CS    PIN_B2
.................... 
.................... void max_pulse_clk(void) {
....................    output_high(MAX_CLK); delay_us(1); output_low(MAX_CLK);
*
0029:  BSF    03.5
002A:  BCF    06.1
002B:  BCF    03.5
002C:  BSF    06.1
002D:  NOP
002E:  BSF    03.5
002F:  BCF    06.1
0030:  BCF    03.5
0031:  BCF    06.1
.................... }
.................... 
.................... void max_sendByte(int8 data) {
....................    int i;
....................    for(i=0; i<8; i++) {
*
0019:  CLRF   2B
001A:  MOVF   2B,W
001B:  SUBLW  07
001C:  BTFSS  03.0
001D:  GOTO   036
....................       if(data & 0x80) output_high(MAX_DIN);
001E:  BTFSS  2A.7
001F:  GOTO   025
0020:  BSF    03.5
0021:  BCF    06.0
0022:  BCF    03.5
0023:  BSF    06.0
0024:  GOTO   029
....................       else            output_low(MAX_DIN);
0025:  BSF    03.5
0026:  BCF    06.0
0027:  BCF    03.5
0028:  BCF    06.0
....................       max_pulse_clk();
....................       data <<= 1;
*
0032:  BCF    03.0
0033:  RLF    2A,F
0034:  INCF   2B,F
0035:  GOTO   01A
....................    }
0036:  RETURN
.................... }
.................... 
.................... void max_send(int8 reg, int8 data) {
....................    output_low(MAX_CS);
0037:  BSF    03.5
0038:  BCF    06.2
0039:  BCF    03.5
003A:  BCF    06.2
....................    max_sendByte(reg);
003B:  MOVF   28,W
003C:  MOVWF  2A
003D:  CALL   019
....................    max_sendByte(data);
003E:  MOVF   29,W
003F:  MOVWF  2A
0040:  CALL   019
....................    output_high(MAX_CS);
0041:  BSF    03.5
0042:  BCF    06.2
0043:  BCF    03.5
0044:  BSF    06.2
0045:  RETURN
.................... }
.................... 
.................... void max_init(void) {
....................    output_low(MAX_DIN); output_low(MAX_CLK); output_high(MAX_CS);
0046:  BSF    03.5
0047:  BCF    06.0
0048:  BCF    03.5
0049:  BCF    06.0
004A:  BSF    03.5
004B:  BCF    06.1
004C:  BCF    03.5
004D:  BCF    06.1
004E:  BSF    03.5
004F:  BCF    06.2
0050:  BCF    03.5
0051:  BSF    06.2
....................    set_tris_b(0b11111000); 
0052:  MOVLW  F8
0053:  BSF    03.5
0054:  MOVWF  06
....................    delay_ms(50);
0055:  MOVLW  32
0056:  BCF    03.5
0057:  MOVWF  27
0058:  CALL   004
....................    max_send(0x0F, 0x00); // Test Off
0059:  MOVLW  0F
005A:  MOVWF  28
005B:  CLRF   29
005C:  CALL   037
....................    max_send(0x0C, 0x01); // Shutdown Off
005D:  MOVLW  0C
005E:  MOVWF  28
005F:  MOVLW  01
0060:  MOVWF  29
0061:  CALL   037
....................    max_send(0x0B, 0x03); // Scan Limit 4 digitos
0062:  MOVLW  0B
0063:  MOVWF  28
0064:  MOVLW  03
0065:  MOVWF  29
0066:  CALL   037
....................    max_send(0x0A, 0x0F); // Intensidad Max
0067:  MOVLW  0A
0068:  MOVWF  28
0069:  MOVLW  0F
006A:  MOVWF  29
006B:  CALL   037
....................    max_send(0x09, 0xFF); // Decode Mode BCD (todos)
006C:  MOVLW  09
006D:  MOVWF  28
006E:  MOVLW  FF
006F:  MOVWF  29
0070:  CALL   037
....................    // Limpiar pantalla
....................    max_send(1, 0x0F); max_send(2, 0x0F); max_send(3, 0x0F); max_send(4, 0x0F); 
0071:  MOVLW  01
0072:  MOVWF  28
0073:  MOVLW  0F
0074:  MOVWF  29
0075:  CALL   037
0076:  MOVLW  02
0077:  MOVWF  28
0078:  MOVLW  0F
0079:  MOVWF  29
007A:  CALL   037
007B:  MOVLW  03
007C:  MOVWF  28
007D:  MOVLW  0F
007E:  MOVWF  29
007F:  CALL   037
0080:  MOVLW  04
0081:  MOVWF  28
0082:  MOVLW  0F
0083:  MOVWF  29
0084:  CALL   037
0085:  BCF    0A.3
0086:  BCF    0A.4
0087:  GOTO   115 (RETURN)
.................... }
.................... 
.................... #include "Estanque.c"
.................... // --- CONSTANTES PRE-CALCULADAS ---
.................... // Basado en Caudal = 2.0
.................... // Prisma (12m3) -> 6s total -> 1% en 60ms
.................... // Cilindro (21.2m3) -> 10.6s total -> 1% en 106ms
.................... #define VELOCIDAD_PRISMA   60
.................... #define VELOCIDAD_CILINDRO 106
.................... #define DELTA_MS           100   // Tiempo del bucle main
.................... 
.................... // --- VARIABLES GLOBALES ---
.................... int8  nivel = 0;           // 0-100
.................... int8 tiempo_seg = 0;      // Segundos transcurridos
.................... int8  estado = 0;          // 0=Stop, 1=Llenando, 2=Vaciando
.................... 
.................... // --- VARIABLES INTERNAS ---
.................... int16 ms_reloj = 0;        // Contador milisegundos para reloj
.................... int8 ms_agua = 0;         // Contador milisegundos para nivel
.................... int8 velocidad_actual = 60; 
.................... 
.................... void simular_estanque() {
.................... 
....................    // ==========================================
....................    // CASO 1: SISTEMA DETENIDO (Configuración)
....................    // ==========================================
....................    if (estado == 0) {
0088:  MOVF   22,F
0089:  BTFSS  03.2
008A:  GOTO   0B5
....................       
....................       // 1. LEER FORMA (Solo permitimos cambiar si está quieto)
....................       // E0 en Pull-Up: 0 = Prisma, 1 = Cilindro
....................       if (input(PIN_E0) == 0) velocidad_actual = VELOCIDAD_PRISMA;
008B:  BSF    03.5
008C:  BSF    09.0
008D:  BCF    03.5
008E:  BTFSC  09.0
008F:  GOTO   093
0090:  MOVLW  3C
0091:  MOVWF  26
0092:  GOTO   095
....................       else                    velocidad_actual = VELOCIDAD_CILINDRO;
0093:  MOVLW  6A
0094:  MOVWF  26
.................... 
....................       // 2. DETECTAR INICIO LLENADO (E1)
....................       if (input(PIN_E1) == 0 && nivel < 80) {
0095:  BSF    03.5
0096:  BSF    09.1
0097:  BCF    03.5
0098:  BTFSC  09.1
0099:  GOTO   0A5
009A:  MOVF   20,W
009B:  SUBLW  4F
009C:  BTFSS  03.0
009D:  GOTO   0A5
....................          estado = 1;
009E:  MOVLW  01
009F:  MOVWF  22
....................          // Resetear todo al iniciar
....................          tiempo_seg = 0; ms_reloj = 0; ms_agua = 0;
00A0:  CLRF   21
00A1:  CLRF   24
00A2:  CLRF   23
00A3:  CLRF   25
....................       }
00A4:  GOTO   0B4
....................       
....................       // 3. DETECTAR INICIO VACIADO (E2)
....................       else if (input(PIN_E2) == 0 && nivel >= 80) {
00A5:  BSF    03.5
00A6:  BSF    09.2
00A7:  BCF    03.5
00A8:  BTFSC  09.2
00A9:  GOTO   0B4
00AA:  MOVF   20,W
00AB:  SUBLW  4F
00AC:  BTFSC  03.0
00AD:  GOTO   0B4
....................          estado = 2;
00AE:  MOVLW  02
00AF:  MOVWF  22
....................          // Resetear todo al iniciar
....................          tiempo_seg = 0; ms_reloj = 0; ms_agua = 0;
00B0:  CLRF   21
00B1:  CLRF   24
00B2:  CLRF   23
00B3:  CLRF   25
....................       }
....................    }
00B4:  GOTO   0E1
.................... 
....................    // ==========================================
....................    // CASO 2: SISTEMA FUNCIONANDO (Simulación)
....................    // ==========================================
....................    else {
....................       ms_reloj += DELTA_MS;
00B5:  MOVLW  64
00B6:  ADDWF  23,F
00B7:  BTFSC  03.0
00B8:  INCF   24,F
....................       ms_agua  += DELTA_MS;
00B9:  MOVLW  64
00BA:  ADDWF  25,F
.................... 
....................       // A. ACTUALIZAR RELOJ (1 segundo = 1000ms)
....................       if (ms_reloj >= 1000) {
00BB:  MOVF   24,W
00BC:  SUBLW  02
00BD:  BTFSC  03.0
00BE:  GOTO   0C9
00BF:  XORLW  FF
00C0:  BTFSS  03.2
00C1:  GOTO   0C6
00C2:  MOVF   23,W
00C3:  SUBLW  E7
00C4:  BTFSC  03.0
00C5:  GOTO   0C9
....................          tiempo_seg++;
00C6:  INCF   21,F
....................          ms_reloj = 0;
00C7:  CLRF   24
00C8:  CLRF   23
....................       }
.................... 
....................       // B. ACTUALIZAR NIVEL AGUA
....................       if (ms_agua >= velocidad_actual) {
00C9:  MOVF   26,W
00CA:  SUBWF  25,W
00CB:  BTFSS  03.0
00CC:  GOTO   0E1
....................          ms_agua = 0;
00CD:  CLRF   25
.................... 
....................          // Si estamos LLENANDO
....................          if (estado == 1) {
00CE:  DECFSZ 22,W
00CF:  GOTO   0D9
....................             nivel++;
00D0:  INCF   20,F
....................             if (nivel >= 80) { // Meta
00D1:  MOVF   20,W
00D2:  SUBLW  4F
00D3:  BTFSC  03.0
00D4:  GOTO   0D8
....................                nivel = 80; estado = 0; 
00D5:  MOVLW  50
00D6:  MOVWF  20
00D7:  CLRF   22
....................             }
....................          }
00D8:  GOTO   0E1
....................          // Si estamos VACIANDO
....................          else {
....................             nivel--;
00D9:  DECF   20,F
....................             if (nivel <= 20) { // Meta
00DA:  MOVF   20,W
00DB:  SUBLW  14
00DC:  BTFSS  03.0
00DD:  GOTO   0E1
....................                nivel = 20; estado = 0; 
00DE:  MOVLW  14
00DF:  MOVWF  20
00E0:  CLRF   22
....................             }
....................          }
....................       }
....................    }
00E1:  BCF    0A.3
00E2:  BCF    0A.4
00E3:  GOTO   126 (RETURN)
.................... }
.................... 
.................... 
.................... void main() {
*
00F9:  MOVF   03,W
00FA:  ANDLW  1F
00FB:  MOVWF  03
00FC:  CLRF   20
00FD:  CLRF   21
00FE:  CLRF   22
00FF:  CLRF   24
0100:  CLRF   23
0101:  CLRF   25
0102:  MOVLW  3C
0103:  MOVWF  26
0104:  BSF    03.5
0105:  BSF    1F.0
0106:  BSF    1F.1
0107:  BSF    1F.2
0108:  BCF    1F.3
0109:  MOVLW  07
010A:  MOVWF  1C
010B:  BCF    03.7
....................    // --- CONFIGURACIÓN DE HARDWARE ---
....................    setup_adc_ports(NO_ANALOGS); // Pines digitales
010C:  BSF    1F.0
010D:  BSF    1F.1
010E:  BSF    1F.2
010F:  BCF    1F.3
....................    set_tris_e(0b00000111);      // E0, E1, E2 como entradas
0110:  BSF    09.0
0111:  BSF    09.1
0112:  BSF    09.2
....................    
....................    max_init(); // Iniciar Pantalla
0113:  BCF    03.5
0114:  GOTO   046
....................    
....................    // Limpiar displays al inicio
....................    max_send(1, 0); max_send(2, 0); 
0115:  MOVLW  01
0116:  MOVWF  28
0117:  CLRF   29
0118:  CALL   037
0119:  MOVLW  02
011A:  MOVWF  28
011B:  CLRF   29
011C:  CALL   037
....................    max_send(3, 0); max_send(4, 0);
011D:  MOVLW  03
011E:  MOVWF  28
011F:  CLRF   29
0120:  CALL   037
0121:  MOVLW  04
0122:  MOVWF  28
0123:  CLRF   29
0124:  CALL   037
.................... 
....................    // --- BUCLE INFINITO ---
....................    while(TRUE) {
....................       
....................       // 1. Ejecutar Lógica (Todo sucede aquí adentro)
....................       simular_estanque();
0125:  GOTO   088
.................... 
....................       // 2. Mostrar Nivel (Derecha - Digitos 1 y 2)
....................       max_send(1, nivel % 10);
0126:  MOVF   20,W
0127:  MOVWF  28
0128:  MOVLW  0A
0129:  MOVWF  29
012A:  CALL   0E4
012B:  MOVF   77,W
012C:  MOVWF  27
012D:  MOVLW  01
012E:  MOVWF  28
012F:  MOVF   77,W
0130:  MOVWF  29
0131:  CALL   037
....................       max_send(2, (nivel / 10) % 10);
0132:  MOVF   20,W
0133:  MOVWF  28
0134:  MOVLW  0A
0135:  MOVWF  29
0136:  CALL   0E4
0137:  MOVF   78,W
0138:  MOVWF  28
0139:  MOVLW  0A
013A:  MOVWF  29
013B:  CALL   0E4
013C:  MOVF   77,W
013D:  MOVWF  27
013E:  MOVLW  02
013F:  MOVWF  28
0140:  MOVF   77,W
0141:  MOVWF  29
0142:  CALL   037
....................       
....................       // 3. Mostrar Tiempo (Izquierda - Digitos 3 y 4)
....................       max_send(3, tiempo_seg % 10);
0143:  MOVF   21,W
0144:  MOVWF  28
0145:  MOVLW  0A
0146:  MOVWF  29
0147:  CALL   0E4
0148:  MOVF   77,W
0149:  MOVWF  27
014A:  MOVLW  03
014B:  MOVWF  28
014C:  MOVF   77,W
014D:  MOVWF  29
014E:  CALL   037
....................       max_send(4, (tiempo_seg / 10) % 10);
014F:  MOVF   21,W
0150:  MOVWF  28
0151:  MOVLW  0A
0152:  MOVWF  29
0153:  CALL   0E4
0154:  MOVF   78,W
0155:  MOVWF  28
0156:  MOVLW  0A
0157:  MOVWF  29
0158:  CALL   0E4
0159:  MOVF   77,W
015A:  MOVWF  27
015B:  MOVLW  04
015C:  MOVWF  28
015D:  MOVF   77,W
015E:  MOVWF  29
015F:  CALL   037
.................... 
....................       // 4. Base de Tiempo (CRÍTICO: 100ms)
....................       delay_ms(100); 
0160:  MOVLW  64
0161:  MOVWF  27
0162:  CALL   004
0163:  GOTO   125
....................    }
.................... }
0164:  SLEEP

Configuration Fuses:
   Word  1: 3F7A   HS NOWDT NOPUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
